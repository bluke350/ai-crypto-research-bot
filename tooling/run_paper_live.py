"""Run a quick paper-mode simulation using recent Kraken OHLC data.

This script is intentionally small: it fetches recent OHLC via the repo's
`kraken_rest` helper, generates targets with a MovingAverageCrossover, and
executes `run_backtest` using the in-repo `Simulator`. Results are written to
`experiments/artifacts/<run_id>`.

Usage (PowerShell):
    ./.venv/Scripts/python tooling/run_paper_live.py --symbol XBT/USD --cash 10000
"""
from __future__ import annotations
import argparse
import os
import uuid
from datetime import datetime, timedelta, timezone
from src.utils.time import now_utc

import pandas as pd

from src.ingestion.providers import kraken_rest
from src.strategies.moving_average import MovingAverageCrossover
from src.execution.simulator import Simulator
try:
    from src.execution.cost_models import FeeModel, SlippageModel, LatencySampler
except Exception:
    FeeModel = None
    SlippageModel = None
    LatencySampler = None
from src.validation.backtester import run_backtest
from src.ingestion.providers.kraken_paper import PaperBroker
import asyncio
import json
try:
    import websockets
except Exception:
    websockets = None


def fetch_recent_ohlc(symbol: str, minutes: int = 60) -> pd.DataFrame:
    # fetch last `minutes` of 1m bars using get_ohlc; since/end are epoch seconds
    end = int(pd.Timestamp.now(tz="UTC").timestamp())
    since = end - (minutes * 60)
    # kraken_rest.get_ohlc expects interval string like '1m'
    try:
        df = kraken_rest.get_ohlc(symbol, '1m', since, end)
        return df
    except Exception as exc:
        print("kraken REST unavailable or failed (falling back to synthetic data):", exc)
        # synthesize simple OHLC series for minutes back
        # use 'min' instead of deprecated 'T'
        idx = pd.date_range(end=pd.Timestamp.now(tz="UTC").floor('min'), periods=minutes, freq='min', tz='UTC')
        close = (pd.Series(range(len(idx))) * 0.1 + 20000.0).astype(float)
        df = pd.DataFrame({'timestamp': idx, 'open': close, 'high': close + 1.0, 'low': close - 1.0, 'close': close, 'volume': 1.0, 'count': 1})
        return df


def run_backtest_mode(symbol: str, cash: float, minutes: int = 120, short: int = 5, long: int = 20):
    print(f"backtest run: symbol={symbol} minutes={minutes} initial_cash={cash}")
    df = fetch_recent_ohlc(symbol, minutes=minutes)
    prices = df[['timestamp', 'close']].copy().reset_index(drop=True)
    strat = MovingAverageCrossover(short=short, long=long, size=1.0)
    targets = strat.generate_targets(prices)
    # build structured cost models for consistent simulation
    fee = FeeModel(fixed_fee_pct=None) if FeeModel is not None else None
    slip = SlippageModel() if SlippageModel is not None else None
    lat = LatencySampler() if LatencySampler is not None else None
    sim = Simulator(fee_model=fee, slippage_model=slip, latency_model=lat)
    out = run_backtest(prices, targets, sim, initial_cash=float(cash), sizing_mode='units')

    run_id = uuid.uuid4().hex[:8]
    artifacts_dir = os.path.join('experiments', 'artifacts', run_id)
    os.makedirs(artifacts_dir, exist_ok=True)
    out['pnl'].to_csv(os.path.join(artifacts_dir, 'pnl.csv'))
    out['executions'].to_csv(os.path.join(artifacts_dir, 'execs.csv'), index=False)
    print(f"run complete: artifacts -> {artifacts_dir}")
    stats = out.get('stats', {})
    final = out['pnl'].iloc[-1]
    print(f"final portfolio value: {final:.2f}")
    print(f"sim stats: {stats}")
    return artifacts_dir


def run_broker_mode(symbol: str, cash: float, minutes: int = 120, short: int = 5, long: int = 20):
    """Run a paper-mode simulation using PaperBroker to log fills in near-real time.

    This iterates the price series and places simulated market orders via PaperBroker
    to reach the target positions generated by the strategy.
    """
    print(f"broker run: symbol={symbol} minutes={minutes} initial_cash={cash}")
    df = fetch_recent_ohlc(symbol, minutes=minutes)
    prices = df[['timestamp', 'close']].copy().reset_index(drop=True)
    strat = MovingAverageCrossover(short=short, long=long, size=1.0)
    targets = strat.generate_targets(prices)

    run_id = uuid.uuid4().hex[:8]
    artifacts_dir = os.path.join('experiments', 'artifacts', run_id)
    os.makedirs(artifacts_dir, exist_ok=True)
    broker = PaperBroker(run_id=run_id, artifacts_root=os.path.join('experiments', 'artifacts'))

    cash = float(cash)
    position = 0.0
    pnl = []
    exec_rows = []

    for idx, row in prices.iterrows():
        price = float(row['close'])
        target = float(targets.iat[idx])
        delta = target - position
        if abs(delta) > 1e-12:
            side = 'buy' if delta > 0 else 'sell'
            size = abs(delta)
            # place order via PaperBroker (immediate fills)
            fill = broker.place_order(symbol, side, size, price=price, type='market')
            filled = float(fill.get('filled_size', size))
            avg_price = float(fill.get('avg_fill_price', price))
            # update cash/position (PaperBroker doesn't model fees here)
            cash -= avg_price * filled
            position += filled if side == 'buy' else -filled
            rec = dict(fill)
            rec['timestamp'] = row['timestamp']
            exec_rows.append(rec)

        # mark-to-market
        value = cash + position * price
        pnl.append(value)

    # persist results
    import pandas as _pd
    _pd.Series(pnl, index=prices['timestamp']).to_csv(os.path.join(artifacts_dir, 'pnl.csv'))
    _pd.DataFrame(exec_rows).to_csv(os.path.join(artifacts_dir, 'execs.csv'), index=False)
    print(f"broker run complete: artifacts -> {artifacts_dir}")
    print(f"final portfolio value: {pnl[-1]:.2f}")
    return artifacts_dir


def main():
    p = argparse.ArgumentParser()
    p.add_argument('--symbol', default='XBT/USD')
    p.add_argument('--cash', type=float, default=10000.0)
    p.add_argument('--minutes', type=int, default=120)
    p.add_argument('--short', type=int, default=5)
    p.add_argument('--long', type=int, default=20)
    p.add_argument('--use-broker', action='store_true', help='Use PaperBroker live-mode instead of run_backtest')
    p.add_argument('--live-ws', action='store_true', help='Use Kraken WebSocket live feed (continuous)')
    p.add_argument('--dry-run', action='store_true', help='Do not actually place orders; simulate and log only')
    p.add_argument('--max-notional', type=float, default=1e9, help='Maximum notional per order (safety)')
    p.add_argument('--reconnect-max-retries', type=int, default=0, help='Max reconnect attempts (0=infinite)')
    p.add_argument('--reconnect-max-delay', type=int, default=60, help='Max backoff seconds between reconnects')
    args = p.parse_args()

    if getattr(args, 'use_broker', False):
        # broker mode: iterate historical (or synthetic) minutes once or run live
        if getattr(args, 'live_ws', False):
            # run continuous websocket-based loop with reconnect/backoff
            if websockets is None:
                raise RuntimeError("websockets package not installed; install via 'pip install websockets' to use --live-ws")
            asyncio.run(run_live_ws(
                args.symbol, args.cash, short=args.short, long=args.long,
                dry_run=args.dry_run,
                max_notional=args.max_notional,
                max_retries=args.reconnect_max_retries,
                max_backoff=args.reconnect_max_delay,
            ))
        else:
            run_broker_mode(args.symbol, args.cash, minutes=args.minutes, short=args.short, long=args.long)
    else:
        run_backtest_mode(args.symbol, args.cash, minutes=args.minutes, short=args.short, long=args.long)


async def run_live_ws(symbol: str, cash: float, short: int = 5, long: int = 20,
                      dry_run: bool = False, max_notional: float = 1e9,
                      max_retries: int = 0, max_backoff: int = 60):
    """Connect to Kraken WS trade feed and run continuously, placing orders via PaperBroker.

    This is a simple example: it aggregates trades into 1-minute closes, computes
    the moving average crossover, and places market orders to reach target units.
    """
    if websockets is None:
        raise RuntimeError("websockets package required for live ws mode")

    run_id = uuid.uuid4().hex[:8]
    artifacts_dir = os.path.join('experiments', 'artifacts', run_id)
    os.makedirs(artifacts_dir, exist_ok=True)
    broker = PaperBroker(run_id=run_id, artifacts_root=os.path.join('experiments', 'artifacts'))

    log_path = os.path.join(artifacts_dir, 'run.log')

    def log(msg: str):
        line = f"{now_utc().isoformat()}Z {msg}"
        print(msg)
        try:
            with open(log_path, 'a', encoding='utf-8') as fh:
                fh.write(line + '\n')
        except Exception:
            pass

    # keep a time-indexed list of minute-close prices and pnl snapshots
    minute_closes = []  # list of (iso_ts, price)
    pnl_series = []     # list of (iso_ts, portfolio_value)

    def persist_live_state():
        """Persist incremental price, pnl, and exec logs so the dashboard can render live runs."""
        try:
            if minute_closes:
                pd.DataFrame(minute_closes, columns=['timestamp', 'close']).to_csv(
                    os.path.join(artifacts_dir, 'price_series.csv'), index=False
                )
            if pnl_series:
                pd.DataFrame(pnl_series, columns=['timestamp', 'value']).to_csv(
                    os.path.join(artifacts_dir, 'pnl.csv'), index=False
                )
            df_exec = broker.get_exec_log()
            if df_exec is not None and not df_exec.empty:
                df_exec.to_csv(os.path.join(artifacts_dir, 'execs.csv'), index=False)
        except Exception:
            # best-effort persistence; keep running even if write fails
            pass

    uri = "wss://ws.kraken.com"
    sub_msg = json.dumps({"event": "subscribe", "pair": [symbol], "subscription": {"name": "trade"}})

    attempts = 0
    while True:
        attempts += 1
        try:
            log(f"connecting to {uri} and subscribing to trades for {symbol} (attempt {attempts})")
            async with websockets.connect(uri, ping_interval=20) as ws:
                await ws.send(sub_msg)
                log("subscribed; receiving trades. Press Ctrl-C to stop.")
                # per-minute aggregator: {minute_str: last_price}
                current_minute = None
                last_price_for_minute = None
                # track position/cash similar to broker_mode
                cash = float(cash)
                position = 0.0

                async for raw in ws:
                    # Kraken trade messages are arrays; websocket library returns str/json
                    try:
                        msg = json.loads(raw)
                    except Exception:
                        continue

                    if isinstance(msg, list) and len(msg) >= 4 and msg[2] == 'trade':
                        trades = msg[1]
                        for t in trades:
                            try:
                                price = float(t[0])
                                ts = float(t[2])
                            except Exception:
                                continue
                            dt = datetime.fromtimestamp(ts, tz=timezone.utc)
                            minute_str = dt.strftime('%Y%m%dT%H%M')
                            if current_minute is None:
                                current_minute = minute_str
                            if minute_str != current_minute:
                                if last_price_for_minute is not None:
                                    iso_ts = pd.to_datetime(current_minute, format='%Y%m%dT%H%M').isoformat()
                                    minute_closes.append((iso_ts, last_price_for_minute))
                                    closes_series = pd.Series([p for _, p in minute_closes], dtype=float)
                                    if len(closes_series) >= long:
                                        prices_df = pd.DataFrame({'timestamp': pd.to_datetime([m for m, _ in minute_closes]), 'close': closes_series.values})
                                        strat = MovingAverageCrossover(short=short, long=long, size=1.0)
                                        targets = strat.generate_targets(prices_df)
                                        target = float(targets.iat[-1])
                                        delta = target - position
                                        if abs(delta) > 1e-12:
                                            side = 'buy' if delta > 0 else 'sell'
                                            size = abs(delta)
                                            notional = size * last_price_for_minute
                                            if not dry_run and notional <= max_notional:
                                                fill = broker.place_order(symbol, side, size, price=last_price_for_minute, type='market')
                                                filled = float(fill.get('filled_size', size))
                                                avg_price = float(fill.get('avg_fill_price', last_price_for_minute))
                                                cash -= avg_price * filled
                                                position += filled if side == 'buy' else -filled
                                            else:
                                                # log simulated order
                                                log(f"DRY/SKIP order: side={side} size={size} notional={notional:.2f}")
                                    # record marked-to-market after processing the minute
                                    portfolio_value = cash + position * last_price_for_minute
                                    pnl_series.append((iso_ts, portfolio_value))
                                    persist_live_state()
                                current_minute = minute_str
                                last_price_for_minute = price
                            else:
                                last_price_for_minute = price
                    else:
                        continue
        except KeyboardInterrupt:
            log("stopping live run")
            break
        except (OSError, Exception) as exc:
            log(f"live ws connection error: {exc}")
            # decide whether to retry
            if max_retries and attempts >= max_retries:
                log("max reconnect attempts reached; exiting")
                break
            backoff = min(max_backoff, 2 ** min(attempts, 10))
            log(f"reconnecting in {backoff}s (attempt {attempts})")
            await asyncio.sleep(backoff)
            continue
        finally:
            persist_live_state()
            log(f"live broker run complete: artifacts -> {artifacts_dir}")


if __name__ == '__main__':
    main()
